(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{421:function(s,t,a){"use strict";a.r(t);var n=a(7),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[s._v("#")]),s._v(" 介绍")]),s._v(" "),t("p",[s._v("TypeScript 中的 "),t("strong",[s._v("类型兼容性（Type Compatibility）")]),s._v(" 是基于 "),t("strong",[s._v("结构子类型（structural subtyping）")]),s._v(" 的。结构类型是一种仅基于其成员来关联类型的方法。这与名义类型相反。思考以下代码:")]),s._v(" "),t("div",{staticClass:"language-ts line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interface")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Pet")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  name"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("string")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Dog")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  name"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("string")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" pet"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" Pet"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// OK, because of structural typing")]),s._v("\npet "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Dog")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[s._v("在名义类型语言中，如 c# 或 Java，等价的代码将是错误的，因为 "),t("code",[s._v("Dog")]),s._v(" 类没有显式地将自己描述为 "),t("code",[s._v("Pet")]),s._v(" 接口的实现者。")]),s._v(" "),t("p",[s._v("TypeScript 的结构类型系统是基于 JavaScript 代码通常的编写方式设计的。因为 JavaScript 广泛使用匿名对象，比如：函数表达式和对象字面量，所以用结构类型系统而不是名义类型系统来表示 JavaScript 库中的各种关系要自然得多。")]),s._v(" "),t("br"),s._v(" "),t("h3",{attrs:{id:"稳固性说明-a-note-on-soundness"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#稳固性说明-a-note-on-soundness"}},[s._v("#")]),s._v(" 稳固性说明 (A Note on Soundness)")]),s._v(" "),t("p",[s._v("TypeScript 的类型系统允许某些在编译时不知道的操作是安全的。当一个类型系统具有这种属性时，就说它不是 “健全的”。TypeScript 允许不合理的行为的地方是经过仔细考虑的，在整个文档中，我们将解释这些情况发生的地方以及它们背后的有利场景。")])])}),[],!1,null,null,null);t.default=e.exports}}]);