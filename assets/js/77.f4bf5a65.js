(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{390:function(e,v,_){"use strict";_.r(v);var t=_(7),s=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"新文件扩展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新文件扩展"}},[e._v("#")]),e._v(" 新文件扩展")]),e._v(" "),v("h4",{attrs:{id:"新文件扩展-new-file-extensions"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新文件扩展-new-file-extensions"}},[e._v("#")]),e._v(" 新文件扩展（New File Extensions）")]),e._v(" "),v("br"),e._v(" "),v("p",[v("code",[e._v("package.json")]),e._v(" 中的 "),v("code",[e._v("type")]),e._v(" 字段是不错的，因为它允许我们继续使用 "),v("code",[e._v(".ts")]),e._v(" 和 "),v("code",[e._v(".js")]),e._v(" 文件扩展名，这很方便；但是，您有时需要编写不同于 "),v("code",[e._v("type")]),e._v(" 所指定的文件。你也可能只是喜欢总是明确的。")]),e._v(" "),v("p",[e._v("Node.js 支持两个扩展来帮助实现这一点： "),v("code",[e._v(".mjs")]),e._v("和 "),v("code",[e._v(".cjs")]),e._v("。"),v("code",[e._v(".mjs")]),e._v(" 文件总是 ES 模块，"),v("code",[e._v(".cjs")]),e._v(" 文件总是 CommonJS 模块，并且没有办法覆盖这些模块。")]),e._v(" "),v("p",[e._v("相应地，TypeScript 支持两个新的源文件扩展名: "),v("code",[e._v(".mts")]),e._v(" 和 "),v("code",[e._v(".cts")]),e._v("。当 TypeScript 将它们输出到 JavaScript 文件时，它将分别输出到 "),v("code",[e._v(".mjs")]),e._v(" 和 "),v("code",[e._v(".cjs")]),e._v("。")]),e._v(" "),v("p",[e._v("此外，TypeScript 还支持两个新的声明文件扩展名: "),v("code",[e._v(".d.mts")]),e._v(" 和 "),v("code",[e._v(".d.cts")]),e._v("。当 TypeScript 生成 "),v("code",[e._v(".mts")]),e._v(" 和 "),v("code",[e._v(".cts")]),e._v(" 的声明文件时，它们对应的扩展名将是 "),v("code",[e._v(".d.mts")]),e._v(" 和 "),v("code",[e._v(".d.cts")]),e._v("。")]),e._v(" "),v("p",[e._v("使用这些扩展完全是可选的，但即使您选择不将它们作为主要工作流程的一部分，它们也通常是有用的。")])])}),[],!1,null,null,null);v.default=s.exports}}]);