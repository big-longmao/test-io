(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{393:function(t,e,o){"use strict";o.r(e);var r=o(7),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.typescriptlang.org/docs/handbook/modules.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Modules 官方文档"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("从 ECMAScript 2015 开始，JavaScript 有了模块的概念。TypeScript 也有这个概念。")]),t._v(" "),e("p",[t._v("模块在它们自己的作用域中执行，而不是在全局作用域中; 这意味着在模块中声明的变量、函数、类等在模块外部是不可见的，除非使用其中的 "),e("strong",[e("code",[t._v("export")])]),t._v(" 显式导出它们。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用其中一个 "),e("strong",[e("code",[t._v("import")])]),t._v(" 来导入。")]),t._v(" "),e("p",[t._v("模块是自声明的; 模块之间的关系是根据文件级别的 imports 和 exports 来指定的。")]),t._v(" "),e("p",[t._v("模块使用模块加载器相互导入。在运行时，模块加载器负责在执行模块之前定位和执行模块的所有依赖项。JavaScript 中使用的著名的模块加载器是 Node.js 的用于 "),e("code",[t._v("CommonJS")]),t._v(" 模块的加载器和 "),e("code",[t._v("Web")]),t._v(" 应用程序中用于 "),e("code",[t._v("AMD")]),t._v(" 模块的 "),e("code",[t._v("RequireJS")]),t._v(" 加载器。")]),t._v(" "),e("p",[t._v("在 TypeScript 中，就像在 ECMAScript 2015 中一样，任何包含顶层 "),e("code",[t._v("import")]),t._v(" 或 "),e("code",[t._v("export")]),t._v(" 的文件都被认为是一个模块。相反，没有任何顶层 "),e("code",[t._v("import")]),t._v(" 或 "),e("code",[t._v("export")]),t._v(" 声明的文件被视为脚本，其内容在全局作用域中可用(因此也可用于模块)。")])])}),[],!1,null,null,null);e.default=v.exports}}]);